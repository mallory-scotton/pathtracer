///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <algorithm>
#include <memory>
#include <string>
#include <map>
#include <unordered_map>
#include <set>
#include <atomic>
#include <unordered_set>
#include <vector>
#include <array>
#include <optional>
#include <filesystem>
#include <stack>
#include <thread>
#include <variant>
#include <mutex>
#include <functional>
#include <istream>
#include <fstream>
#include <tuple>
#include <any>
#include <queue>
#include <iostream>
#include <regex>

///////////////////////////////////////////////////////////////////////////////
// Namespace Ray
///////////////////////////////////////////////////////////////////////////////
namespace Ray
{

///////////////////////////////////////////////////////////////////////////////
using Regex = std::regex;

///////////////////////////////////////////////////////////////////////////////
using Any = std::any;

///////////////////////////////////////////////////////////////////////////////
using OfStream = std::ofstream;
using IfStream = std::ifstream;

///////////////////////////////////////////////////////////////////////////////
using Path = std::filesystem::path;

///////////////////////////////////////////////////////////////////////////////
using Thread = std::thread;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Queue = std::queue<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename R> using Function = std::function<R>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Atomic = std::atomic<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Stack = std::stack<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename... Ts> using Variant = std::variant<Ts...>;

///////////////////////////////////////////////////////////////////////////////
template <typename T, typename U> using Map = std::map<T, U>;
template <typename T, typename U> using UnorderedMap = std::unordered_map<T, U>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Set = std::set<T>;
template <typename T> using UnorderedSet = std::unordered_set<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T, typename U> using Pair = std::pair<T, U>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Optional = std::optional<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using SharedPtr = std::shared_ptr<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using WeakPtr = std::weak_ptr<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using UniquePtr = std::unique_ptr<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Vector = std::vector<T>;

///////////////////////////////////////////////////////////////////////////////
typedef unsigned char Uint8;
typedef unsigned short Uint16;
typedef unsigned int Uint32;
typedef unsigned long Uint64;

///////////////////////////////////////////////////////////////////////////////
template <typename T, Uint64 S> using Array = std::array<T, S>;

///////////////////////////////////////////////////////////////////////////////
template <typename... Ts> using Tuple = std::tuple<Ts...>;

///////////////////////////////////////////////////////////////////////////////
typedef signed char Int8;
typedef signed short Int16;
typedef signed int Int32;
typedef signed long Int64;

///////////////////////////////////////////////////////////////////////////////
typedef unsigned char Byte;

///////////////////////////////////////////////////////////////////////////////
using Mutex = std::mutex;

///////////////////////////////////////////////////////////////////////////////
using String = std::string;

///////////////////////////////////////////////////////////////////////////////
using StringStream = std::stringstream;

} // namespace Ray
